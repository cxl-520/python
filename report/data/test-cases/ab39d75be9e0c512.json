{"uid":"ab39d75be9e0c512","name":"上传图片接口","fullName":"testcase.test_api.test_posts.Test_api#test_上传图片接口","historyId":"61a87824673656281afb4d3241204947","time":{"start":1770712305155,"stop":1770712305233,"duration":78},"description":"\n         ### 上传图片接口\n        **测试场景**：上传合法图片文件\n        **预期结果**：HTTP状态码200，业务码200，返回图片URL\n        **前置条件**：无\n        ","descriptionHtml":"<pre><code>     ### 上传图片接口\n    **测试场景**：上传合法图片文件\n    **预期结果**：HTTP状态码200，业务码200，返回图片URL\n    **前置条件**：无\n</code></pre>\n","status":"failed","statusMessage":"Failed: 获取人气选手接口测试失败：Expecting value: line 1 column 1 (char 0)","statusTrace":"self = <Response [502]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Decodes the JSON response body (if any) as a Python object.\n    \n        This may return a dictionary, list, etc. depending on what is in the response.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n>           return complexjson.loads(self.text, **kwargs)\n\n.venv\\lib\\site-packages\\requests\\models.py:976: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\json\\__init__.py:346: in loads\n    return _default_decoder.decode(s)\n..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\json\\decoder.py:337: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <json.decoder.JSONDecoder object at 0x000002DCA9191310>, s = '', idx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n        a JSON document) and return a 2-tuple of the Python\n        representation and the index in ``s`` where the document ended.\n    \n        This can be used to decode a JSON document from a string that may\n        have extraneous data at the end.\n    \n        \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\json\\decoder.py:355: JSONDecodeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <testcase.test_api.test_posts.Test_api object at 0x000002DCAC18FF70>\n\n    @allure.description(\"\"\"\n         ### 上传图片接口\n        **测试场景**：上传合法图片文件\n        **预期结果**：HTTP状态码200，业务码200，返回图片URL\n        **前置条件**：无\n        \"\"\")\n    @allure.title(\"上传图片接口\")\n    @allure.severity(allure.severity_level.NORMAL)\n    def test_上传图片接口(self):\n        url = \"http://idrc.iflight-rc.com/api/ajax/upload\"\n        file_path = r\"D:\\Pictures\\微信图片_20251017214318_93_82.jpg\"\n        with open(file_path, \"rb\") as f:\n            post_data = {\n                # requests文件上传的元组规则,代码要给接口传递带后缀的文件名，要不然会导致接口无法识别 PNG 格式\n                \"file\": (\"微信图片_20251017214318_93_82.jpg\", f, \"image/jpg\"),\n                \"category\": \"\"\n            }\n            with allure.step(\"步骤2：发送GET请求并校验响应\"):\n                try:\n                    res1 = requests.post(url=url, files=post_data, timeout=5)\n                    # 打印响应详情（关键：看服务器返回的错误信息）\n                    print(f\"响应状态码：{res1.status_code}\")\n>                   print(f\"响应内容：{res1.json()}\")\n\ntestcase\\test_api\\test_posts.py:31: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Response [502]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Decodes the JSON response body (if any) as a Python object.\n    \n        This may return a dictionary, list, etc. depending on what is in the response.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n            return complexjson.loads(self.text, **kwargs)\n        except JSONDecodeError as e:\n            # Catch JSON-related errors and raise as requests.JSONDecodeError\n            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError\n>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\nE           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n.venv\\lib\\site-packages\\requests\\models.py:980: JSONDecodeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <testcase.test_api.test_posts.Test_api object at 0x000002DCAC18FF70>\n\n    @allure.description(\"\"\"\n         ### 上传图片接口\n        **测试场景**：上传合法图片文件\n        **预期结果**：HTTP状态码200，业务码200，返回图片URL\n        **前置条件**：无\n        \"\"\")\n    @allure.title(\"上传图片接口\")\n    @allure.severity(allure.severity_level.NORMAL)\n    def test_上传图片接口(self):\n        url = \"http://idrc.iflight-rc.com/api/ajax/upload\"\n        file_path = r\"D:\\Pictures\\微信图片_20251017214318_93_82.jpg\"\n        with open(file_path, \"rb\") as f:\n            post_data = {\n                # requests文件上传的元组规则,代码要给接口传递带后缀的文件名，要不然会导致接口无法识别 PNG 格式\n                \"file\": (\"微信图片_20251017214318_93_82.jpg\", f, \"image/jpg\"),\n                \"category\": \"\"\n            }\n            with allure.step(\"步骤2：发送GET请求并校验响应\"):\n                try:\n                    res1 = requests.post(url=url, files=post_data, timeout=5)\n                    # 打印响应详情（关键：看服务器返回的错误信息）\n                    print(f\"响应状态码：{res1.status_code}\")\n                    print(f\"响应内容：{res1.json()}\")\n                    # 1. 校验HTTP状态码\n                    assert res1.status_code == 200\n                except requests.exceptions.Timeout:\n                    allure.attach(\"请求超时（5秒内未响应）\", name=\"异常信息\", attachment_type=allure.attachment_type.TEXT)\n                    pytest.fail(\"获取人气选手接口请求超时\")\n                except requests.exceptions.ConnectionError:\n                    allure.attach(\"网络连接失败\", name=\"异常信息\", attachment_type=allure.attachment_type.TEXT)\n                    pytest.fail(\"获取人气选手接口网络连接失败\")\n                except AssertionError as e:\n                    allure.attach(str(e), name=\"断言失败信息\", attachment_type=allure.attachment_type.TEXT)\n                    raise  # 重新抛出，标记用例失败\n                except Exception as e:\n                    allure.attach(f\"未知异常：{str(e)}\", name=\"异常信息\", attachment_type=allure.attachment_type.TEXT)\n>                   pytest.fail(f\"获取人气选手接口测试失败：{e}\")\nE                   Failed: 获取人气选手接口测试失败：Expecting value: line 1 column 1 (char 0)\n\ntestcase\\test_api\\test_posts.py:45: Failed","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[],"testStage":{"description":"\n         ### 上传图片接口\n        **测试场景**：上传合法图片文件\n        **预期结果**：HTTP状态码200，业务码200，返回图片URL\n        **前置条件**：无\n        ","status":"failed","statusMessage":"Failed: 获取人气选手接口测试失败：Expecting value: line 1 column 1 (char 0)","statusTrace":"self = <Response [502]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Decodes the JSON response body (if any) as a Python object.\n    \n        This may return a dictionary, list, etc. depending on what is in the response.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n>           return complexjson.loads(self.text, **kwargs)\n\n.venv\\lib\\site-packages\\requests\\models.py:976: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\json\\__init__.py:346: in loads\n    return _default_decoder.decode(s)\n..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\json\\decoder.py:337: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <json.decoder.JSONDecoder object at 0x000002DCA9191310>, s = '', idx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n        a JSON document) and return a 2-tuple of the Python\n        representation and the index in ``s`` where the document ended.\n    \n        This can be used to decode a JSON document from a string that may\n        have extraneous data at the end.\n    \n        \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n..\\..\\AppData\\Local\\Programs\\Python\\Python39\\lib\\json\\decoder.py:355: JSONDecodeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <testcase.test_api.test_posts.Test_api object at 0x000002DCAC18FF70>\n\n    @allure.description(\"\"\"\n         ### 上传图片接口\n        **测试场景**：上传合法图片文件\n        **预期结果**：HTTP状态码200，业务码200，返回图片URL\n        **前置条件**：无\n        \"\"\")\n    @allure.title(\"上传图片接口\")\n    @allure.severity(allure.severity_level.NORMAL)\n    def test_上传图片接口(self):\n        url = \"http://idrc.iflight-rc.com/api/ajax/upload\"\n        file_path = r\"D:\\Pictures\\微信图片_20251017214318_93_82.jpg\"\n        with open(file_path, \"rb\") as f:\n            post_data = {\n                # requests文件上传的元组规则,代码要给接口传递带后缀的文件名，要不然会导致接口无法识别 PNG 格式\n                \"file\": (\"微信图片_20251017214318_93_82.jpg\", f, \"image/jpg\"),\n                \"category\": \"\"\n            }\n            with allure.step(\"步骤2：发送GET请求并校验响应\"):\n                try:\n                    res1 = requests.post(url=url, files=post_data, timeout=5)\n                    # 打印响应详情（关键：看服务器返回的错误信息）\n                    print(f\"响应状态码：{res1.status_code}\")\n>                   print(f\"响应内容：{res1.json()}\")\n\ntestcase\\test_api\\test_posts.py:31: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Response [502]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Decodes the JSON response body (if any) as a Python object.\n    \n        This may return a dictionary, list, etc. depending on what is in the response.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n            return complexjson.loads(self.text, **kwargs)\n        except JSONDecodeError as e:\n            # Catch JSON-related errors and raise as requests.JSONDecodeError\n            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError\n>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\nE           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n.venv\\lib\\site-packages\\requests\\models.py:980: JSONDecodeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <testcase.test_api.test_posts.Test_api object at 0x000002DCAC18FF70>\n\n    @allure.description(\"\"\"\n         ### 上传图片接口\n        **测试场景**：上传合法图片文件\n        **预期结果**：HTTP状态码200，业务码200，返回图片URL\n        **前置条件**：无\n        \"\"\")\n    @allure.title(\"上传图片接口\")\n    @allure.severity(allure.severity_level.NORMAL)\n    def test_上传图片接口(self):\n        url = \"http://idrc.iflight-rc.com/api/ajax/upload\"\n        file_path = r\"D:\\Pictures\\微信图片_20251017214318_93_82.jpg\"\n        with open(file_path, \"rb\") as f:\n            post_data = {\n                # requests文件上传的元组规则,代码要给接口传递带后缀的文件名，要不然会导致接口无法识别 PNG 格式\n                \"file\": (\"微信图片_20251017214318_93_82.jpg\", f, \"image/jpg\"),\n                \"category\": \"\"\n            }\n            with allure.step(\"步骤2：发送GET请求并校验响应\"):\n                try:\n                    res1 = requests.post(url=url, files=post_data, timeout=5)\n                    # 打印响应详情（关键：看服务器返回的错误信息）\n                    print(f\"响应状态码：{res1.status_code}\")\n                    print(f\"响应内容：{res1.json()}\")\n                    # 1. 校验HTTP状态码\n                    assert res1.status_code == 200\n                except requests.exceptions.Timeout:\n                    allure.attach(\"请求超时（5秒内未响应）\", name=\"异常信息\", attachment_type=allure.attachment_type.TEXT)\n                    pytest.fail(\"获取人气选手接口请求超时\")\n                except requests.exceptions.ConnectionError:\n                    allure.attach(\"网络连接失败\", name=\"异常信息\", attachment_type=allure.attachment_type.TEXT)\n                    pytest.fail(\"获取人气选手接口网络连接失败\")\n                except AssertionError as e:\n                    allure.attach(str(e), name=\"断言失败信息\", attachment_type=allure.attachment_type.TEXT)\n                    raise  # 重新抛出，标记用例失败\n                except Exception as e:\n                    allure.attach(f\"未知异常：{str(e)}\", name=\"异常信息\", attachment_type=allure.attachment_type.TEXT)\n>                   pytest.fail(f\"获取人气选手接口测试失败：{e}\")\nE                   Failed: 获取人气选手接口测试失败：Expecting value: line 1 column 1 (char 0)\n\ntestcase\\test_api\\test_posts.py:45: Failed","steps":[{"name":"步骤2：发送GET请求并校验响应","time":{"start":1770712305156,"stop":1770712305232,"duration":76},"status":"failed","statusMessage":"Failed: 获取人气选手接口测试失败：Expecting value: line 1 column 1 (char 0)\n","statusTrace":"  File \"C:\\Users\\Administrator\\PycharmProjects\\PythonProject\\testcase\\test_api\\test_posts.py\", line 45, in test_上传图片接口\n    pytest.fail(f\"获取人气选手接口测试失败：{e}\")\n  File \"C:\\Users\\Administrator\\PycharmProjects\\PythonProject\\.venv\\lib\\site-packages\\_pytest\\outcomes.py\", line 177, in fail\n    raise Failed(msg=reason, pytrace=pytrace)\n","steps":[],"attachments":[{"uid":"7bd546ac20f27537","name":"异常信息","source":"7bd546ac20f27537.txt","type":"text/plain","size":56}],"parameters":[],"hasContent":true,"attachmentsCount":1,"attachmentStep":false,"stepsCount":0,"shouldDisplayMessage":true}],"attachments":[],"parameters":[],"hasContent":true,"attachmentsCount":1,"attachmentStep":false,"stepsCount":1,"shouldDisplayMessage":true},"afterStages":[],"labels":[{"name":"severity","value":"normal"},{"name":"feature","value":"接口自动化测试post请求"},{"name":"story","value":"apifox文档上的idrc接口"},{"name":"parentSuite","value":"testcase.test_api"},{"name":"suite","value":"test_posts"},{"name":"subSuite","value":"Test_api"},{"name":"host","value":"PC-20250907ITIM"},{"name":"thread","value":"14800-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"testcase.test_api.test_posts"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Product defects","matchedStatuses":[]}],"tags":[]},"source":"ab39d75be9e0c512.json","parameterValues":[]}